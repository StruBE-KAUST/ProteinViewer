<!-- Note: scripts defines on this page cannot be moved because they make reference to the context sent with the render request -->

<!DOCTYPE html>
<html>
  <head>
    <title>VR Molecules!</title>
    <meta name="description" content="View your molecule in Virtual Reality!">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="-1">
    <meta http-equiv="CACHE-CONTROL" content="NO-CACHE">
    <script src="https://aframe.io/releases/0.5.0/aframe.js"></script>
    <script src="https://rawgit.com/sparksia/aframe-physics-system/master/dist/aframe-physics-system.js"></script>
    <script src="https://rawgit.com/sparksia/aframe-extras/master/dist/aframe-extras.js"></script>
    <script src="https://unpkg.com/aframe-line-component/dist/aframe-line-component.min.js"></script>
    {% load static %}
    <script src={% static "js/aframe-physics-collider.js" %}></script>
    <script src={% static "js/aframe-physics-collision-filter.js" %}></script>
    <script src="https://code.jquery.com/jquery-3.2.1.js"></script>
    <script src={% static "js/event-state.js" %}></script>
    <script src={% static "js/cookie.js" %}></script>
    <script>
      // set the position of each domain using vectors from renderRelative.py
      $(function(){
        scene = document.getElementById('scene');
        shift = {{ shift }};
        // parameter used in grab.js
        scene.shift = shift;
        scene.directory = "{{ temporary_directory }}";

        data = {'do_all': 0, 'grab_number': 0, 'presses': 0};

        $.ajax({
          async: true,
          type: 'POST',
          url: "relative/",
          data: data
        }).done(function(data){

          domain_positions = data[1];
          linker_positions = data[2];
          scene.domain_positions = {};

          for(var i=0; i<domain_positions.length; i++){
            position = JSON.parse(domain_positions[i]);
          // TODO: send dictionary instead, string slow {x:0, y:0, z:0} <- dict doesn't work!!
            position_str = position[0] + " " + position[1] + " " + position[2];
            // position_dict = {x: pos[0], y: pos[1], z: pos[2]};
            piece_id = "#dom" + i;
            piece = document.getElementById('dom' + i);
            piece.setAttribute('position', position_str);
            scene.domain_positions['dom' + i] = position;
          }

          for(var i=0; i<linker_positions.length; i++){
            position = JSON.parse(linker_positions[i]);
            position_str = position[0] + " " + position[1] + " " + position[2];
            piece_id = "#link" + i;
            piece = document.getElementById('link' + i);
            piece.setAttribute('position', position_str);
          }
        });      
      });      
    </script>
    <script>
    function sendNewCoords(grab_number){
      /*
        Send coordinates from aframe to pdbs by making an ajax call to aframeData
        @param grab_number: the number fo times the user moved domains
        @type grab_number: int
      */

      scene = document.getElementById('scene');

      presses = scene.press;
      scene.loading = true;
      temporary_directory = scene.directory;

      representation = {{ representation }};

      // lines change color to indicate loading
      var lines = document.querySelectorAll('.line');
      for(var i=0; i<lines.length; i++){
        line = document.getElementById('line' + i);
        line.setAttribute('line', 'color', '#ffff00');
      }

      var pass = {};

      domains = document.querySelectorAll('.domain');

      // get the matrix describing each domain's new position and rotation
      for(var i=0; i<num; i++){
        position = domains[i].getAttribute('position');
        matrix = new THREE.Matrix4;
        quaternion = new THREE.Quaternion;
        elements = domains[i].object3D.matrixWorld.elements;

        // since the rotation happening in PDBModel seems to be the opposite of what we want, try transpose the rotation part only: get rid of position data, transpose it, then add on position data
        elements[12] = elements[13] = elements[14] = 0;

        matrix.fromArray(elements);

        old_position = scene.domain_positions['dom' + i];

        delx = position['x'] - old_position[0];
        dely = position['y'] - old_position[1];
        delz = position['z'] - old_position[2];

        delta_position = {'x': delx, 'y': dely, 'z': delz};
        matrix.setPosition(delta_position);
        matrix.transpose();

        matrix = matrix.elements.toString();

        pass['mat' + i] = matrix;

        scene.domain_positions['dom' + i] = [position['x'], position['y'], position['z']];
      }

      pass['grab_number'] = grab_number;
      pass['presses'] = presses;

      $.ajax({
        async: true,
        type: "POST",
        url: "return/",
        data: pass
      }).done(function(msg) {
        FAILED_STATE = -1

        scene = document.getElementById('scene');
        presses = scene.press;
        grab_number = msg[1];

        // if the configuration is not possible, turn the lines red. Otherwise, set the lines back to length 0 and put in the linkers.
        if(msg[0] == presses && msg[2] == FAILED_STATE){
          for(var i=0; i<lines.length; i++){
            line = document.getElementById('line' + i);
            line.setAttribute('line', 'color', '#ff0000');
            scene.loading = false;
          }
        } else if(msg[0] == presses) {
          // this if is necessary to make sure the linkers from only the last move is loaded
          data = {'do_all': -1, 'grab_number': grab_number, 'presses': presses};
          $.ajax({
            async: true,
            type: 'POST',
            url: "relative/",
            data: data
          }).done(function(data){
            scene = document.getElementById('scene');
            temporary_directory = scene.directory;

            presses = data[0];
            domain_positions = data[1];
            linker_positions = data[2]; 

            // reset lines
            if(presses == scene.press){
              for(var i=0; i<lines.length; i++){
                line = document.getElementById('line' + i);
                line.setAttribute('line', 'color', '#00ff00');
                line.setAttribute('line', 'start', '0 0 0');
                line.setAttribute('line', 'end', '0 0 0');
              }

              // load linkers
              for(var i=0; i<linker_positions.length; i++){
                position = JSON.parse(linker_positions[i]);
                position_str = position[0] + " " + position[1] + " " + position[2];
                piece = document.getElementById('link' + i);
                piece.setAttribute('obj-model', 'obj', temporary_directory + '/link' + i + '.' + grab_number + '.obj');
                piece.setAttribute('obj-model', 'mtl', temporary_directory + '/link' + i + '.' + grab_number + '.mtl');
                piece.setAttribute('position', position_str);
              }
              scene.loading = false;
            }
          });  
        } else {
          console.log('not matching');
        }
      });
    }
    </script>
    <script src={% static "js/follow.js" %}></script>
    <script src={% static "js/stuck.js" %}></script>
    <script src={% static "js/grab.js" %}></script>
    <script src={% static "js/react.js" %}></script>
    <!-- <script src={% static "js/THREE.MeshLine.js" %}></script> -->
  </head>

  <body>


  <a-scene id="scene" physics="debug: true; gravity: 0" stats debug>
    <a-assets>
      <a-mixin id = "controller" action event-state></a-mixin>
      <a-mixin id = "controller-loaded" 
                 static-body="shape: sphere; sphereRadius: 0.05;" 
                 physics-collider
                 collision-filter = "group: green; collidesWith: default, red, green;"
                 >
      </a-mixin>

      <a-mixin id="cube" geometry="primitive: box; width: 0.01; height: 0.01; depth: 0.01"></a-mixin>

      <a-mixin id="cube-collided" material="opacity: 0.7; transparent: true"></a-mixin>

      <a-mixin id="molecule" stuck></a-mixin>
      <a-mixin id="dymol" stuck dynamic-body="shape: box; linearDamping: 0.99; angularDamping: 0.99" collision-filter="group: red; collidesWith: default, red, green"></a-mixin>
      <a-mixin id="dylink"></a-mixin>
      <a-mixin id="collider" stuck dynamic-body="shape: hull; linearDamping: 0.99; angularDamping: 0.99"></a-mixin>

      <!-- Get the asset string that was build in views.py -->
      <!-- {{ assets |safe }} -->

      {% for asset in assets %}
        <a-asset-item id={{asset.obj_id}} src={{asset.obj_src}}></a-asset-item>
        <a-asset-item id={{asset.mat_id}} src={{asset.mat_src}}></a-asset-item>
      {% endfor %}
    </a-assets>

    <!-- loads the protein models -->

    <!-- Get the entities that were built in views.py -->
    <!-- {{ entities |safe }} -->
    {% for entity in entities %}
      <a-entity id={{entity.entity_id}} mixin={{entity.entity_mixin}} class={{entity.entity_class}} obj-model="obj: {{entity.entity_obj}}; mtl: {{entity.entity_mat}}"></a-entity>
    {% endfor %}

    {% for box in boxes %} 
      <a-entity id={{box.box_id}} mixin="cube" class="collision" position={{box.position}} meterial="transparent: true; opacity: 0" follow="target: {{box.target}}" line={{box.line}}></a-entity>
    {% endfor %}

    {% for line in lines %}
      <a-entity id={{line.line_id}} class="line" line="start: 0 0 0; end: 0 0 0; color: #00ff00" startbox={{line.line_start_box}} endbox={{line.line_end_box}}></a-entity>
    {% endfor %}

    <!-- Box that acts as the center; entities "stick" to it -->
    <a-box id="center" mixin="cube" material="transparent: true; opacity: 0" static-body collision-filter="group: default"></a-box>





    <!-- Hull, Collada model -->

    <!-- TODO: Use as referance when using hull colliders; need to use hull models in dae format for best results -->

    <!-- <a-entity id="daehull" class="model" collada-model="#hulldae" position="-0.5 1 1" collision-filter="group: red; collidesWith: default, red, green" stuck dynamic-body="shape: hull; linearDamping: 0.99; angularDamping: 0.99" follow="target: mol1"></a-entity> -->
    <!-- <a-entity id="mol1" class="complex" obj-model="obj: #model1; mtl: #mat1" position= "-0.5 1 1"></a-entity> -->

    <!-- <a-entity id="daehull2" class="model" collada-model="#hulldae2" position="0.5 1 1" collision-filter="group: red; collidesWith: default, red, green" stuck dynamic-body="shape: hull; linearDamping: 0.99; angularDamping: 0.99" follow="target: mol2"></a-entity> -->
    <!-- <a-entity id="mol2" class="complex" obj-model="obj: #model2; mtl: #mat2" position= "0.5 1 1"></a-entity> -->

    <!-- <a-entity class="model" id="blue" mixin="cube" material="color: blue" position="0 1 -1" constraint="target: #blue"></a-entity>
    <a-entity class="model" id="clear" mixin="cube" material="color: red; opacity: 0; transparent: true" position="0 1 1"></a-entity> -->


    <!-- Skybox (background) -->
    <a-sky src={% static "img/skybox.jpg" %}></a-sky>


    <!-- HTC Vive controllers! -->

    <!-- TODO: Turn on raycasters when hulls are in use; to see if we're "inside" a collider. -->

    <a-entity class="cont" id="left" mixin="controller" vive-controls="hand: left">
      <!-- <a-entity class="ray" id="1" geometry="primitive: box; width: 0.1; height: 0.1; depth: 0.1" raycaster="objects: .collider" material="opacity: 0; transparent: true" rotation="0 180 0" react></a-entity> -->
      <!-- <a-entity class="ray" id="2" geometry="primitive: box; width: 0.1; height: 0.1; depth: 0.1" raycaster="objects: .collider" material="opacity: 0; transparent: true" rotation="0 0 0" react></a-entity> -->
    </a-entity>
    <a-entity class="cont" id="right" mixin="controller" vive-controls="hand: right">
      <!-- <a-entity class="ray" id="1" geometry="primitive: box; width: 0.1; height: 0.1; depth: 0.1" raycaster="objects: .collider" material="opacity: 0; transparent: true" rotation="0 180 0" react></a-entity> -->
      <!-- <a-entity class="ray" id="2" geometry="primitive: box; width: 0.1; height: 0.1; depth: 0.1" raycaster="objects: .collider" material="opacity: 0; transparent: true" rotation="0 0 0" react></a-entity> -->
    </a-entity>

  </a-scene>
  </body>
</html>